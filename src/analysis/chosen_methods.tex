\subsection{Chosen methods}

When considering the fault-tolerance methods to implement, the most crucial factor was the feasibility of implementation. Since we are working with a high-level language, certain methods such as EDDI are not possible to effectively implement, since they require implmenentation at assembly instruction level, however, modified or simplified version of these methods may still be implemented.

Ultimately, checkpoint and restart was chosen as the backbone of fault recovery, as it can be easily combined with other methods. CFCSS, with various modifications to make its implmentation fasible in Rust, was chosen to secure the control flow of the program. Finally, recovery blocks and N-version programming were chosen to facilitate multi-version functionality. Additional miscellaneous fault-tolerance methods were also used, such as variable protection through duplication to support the aforementioned methods.