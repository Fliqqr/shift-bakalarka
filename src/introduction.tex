\section{Introduction}

% \begin{abstract}
With the increasing demand for high-performance embedded software comes the inevitable, difficult task of ensuring error-free functioning of ever-more complex systems. The increased complexity, both in terms of hardware components and software features, increases the number of failure points where faults can manifest an error.

Faults can be caused by both external factors beyond our control such as radiation in space interfering with the hardware, but also as a result of human error while designing the system. Due to the incredibly complex nature of this problem, it is unlikely that we will be designing completely error and fault-free software and hardware in the near future. This makes fault-tolerance an important aspect of software design, especially when designing critical systems whose failure could endanger human life. However, as with most things, fault-tolerance and reliability is a trade-off, which usually comes at the cost of performance and development time.

Historically, specialized hardware was the go-to choice for implementing fault tolerance, specifically by hardening and or duplicating the components. This approach requires designing and producing non-standard computer components, exponentially increasing the development cost. Lately, a more economical solution began gaining traction for non-critical missions. Namely, using off-the-shelf components without specialized hardening, while using software redundancies to implement fault tolerance.

This thesis will aim to analyze various common software-implemented fault-tolerance methods. We will look at the benefits and drawbacks of the utilized methods, as well as construct a working demo based on FreeRTOS running on a simulated RISC-V core, with fault insertion capability, that implements and tests the effectiveness of some selected methods using the Rust programming language.
% \end{abstract}
